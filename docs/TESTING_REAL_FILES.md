# Testing with Real-World Files

This document describes how DevDashboard uses real-world dependency files for testing to ensure compatibility with actual lock file formats.

## Overview

In addition to synthetic test cases with hand-crafted content, DevDashboard includes tests that use actual dependency lock files. This ensures that the parsers can handle real-world files with all their complexity, edge cases, and variations.

## Real File Tests

### uv.lock Test Cases

The project includes two test cases that use a real `uv.lock` file from the `tmp/` directory:

#### 1. `TestUvLockAnalyzer_ParseRealUvLockFile`

**Purpose:** Tests the low-level parsing of a real uv.lock file.

**Location:** `pkg/dependencies/uvlock_test.go`

**What it tests:**
- Successfully parses actual uv.lock TOML content
- Extracts all expected packages by name
- Correctly identifies package versions
- Distinguishes between runtime and dev dependencies
- Handles virtual packages with dev-dependencies

**Expected packages in test file:**
- `cfgv` - Configuration file validation
- `distlib` - Distribution utilities
- `dnspython` - DNS toolkit
- `filelock` - File locking
- `identify` - File identification
- `nodeenv` - Node.js virtual environment
- `platformdirs` - Platform directories
- `pre-commit` - Pre-commit hooks framework
- `pyyaml` - YAML parser
- `tmp` - Test package (virtual, with dev-dependencies)
- `virtualenv` - Virtual environment creator

**Key validations:**
```go
// Verifies the tmp package is correctly identified as dev type
if tmpPkg.Type != "dev" {
    t.Errorf("Package 'tmp' should be marked as 'dev' type")
}
```

#### 2. `TestUvLockAnalyzer_AnalyzeRealUvLockFile`

**Purpose:** Integration test for the complete analysis workflow.

**What it tests:**
- File discovery (CandidateFiles)
- Content retrieval (via mock client)
- Full dependency analysis (AnalyzeDependencies)
- Result aggregation

**Workflow:**
1. Reads actual `tmp/uv.lock` file
2. Creates mock repository client with real content
3. Runs complete analysis flow
4. Validates results match expected packages
5. Verifies dependency type classification

**Expected results:**
- Total: 11 packages
- Runtime: 10 packages
- Dev: 1 package (tmp)

## Test File Location

The test file is located at:
```
devdashboard/tmp/uv.lock
```

This is a real uv.lock file generated by the `uv` package manager for a Python project.

## Graceful Handling of Missing Files

Both tests include logic to gracefully skip when the test file is not present:

```go
content, err := os.ReadFile("../../tmp/uv.lock")
if err != nil {
    t.Skipf("Skipping test: tmp/uv.lock file not found: %v", err)
    return
}
```

This ensures that:
- Tests don't fail in environments without the test file
- CI/CD pipelines can run even if the tmp directory is excluded
- Developers see a clear skip message rather than a failure

## Running the Tests

### Run all dependency tests:
```bash
go test ./pkg/dependencies/... -v
```

### Run only real file tests:
```bash
go test ./pkg/dependencies/... -v -run "Real"
```

### Run with detailed output:
```bash
go test ./pkg/dependencies/... -v -run TestUvLockAnalyzer_ParseRealUvLockFile
```

**Example output:**
```
=== RUN   TestUvLockAnalyzer_ParseRealUvLockFile
    uvlock_test.go:623: Successfully parsed real uv.lock file with 11 dependencies
    uvlock_test.go:640: Found expected package: cfgv v3.4.0 (type: runtime, source: pypi)
    uvlock_test.go:640: Found expected package: distlib v0.4.0 (type: runtime, source: pypi)
    ...
    uvlock_test.go:685: Dependency breakdown: 10 runtime, 1 dev
--- PASS: TestUvLockAnalyzer_ParseRealUvLockFile (0.00s)
```

## Why Real File Tests Matter

### 1. Format Complexity
Real lock files contain:
- Multiple wheel URLs for different platforms
- Complex source specifications
- Upload timestamps and file sizes
- Hash values
- Dependencies with markers
- Virtual packages

### 2. Edge Cases
Real files expose edge cases that synthetic tests might miss:
- Unusual TOML formatting
- Package names with special characters
- Complex dependency trees
- Platform-specific variations

### 3. Regression Prevention
Real files help prevent regressions when:
- The uv format evolves
- TOML parsing library updates
- Struct definitions change

### 4. Confidence
Successfully parsing real files gives confidence that the analyzer will work with actual user projects.

## Adding More Real File Tests

To add tests for other file formats:

### 1. Add the test file
```bash
# Add your real lock file to tmp/
cp /path/to/real/Pipfile.lock tmp/
```

### 2. Create the test case
```go
func TestPipfileAnalyzer_ParseRealPipfileLock(t *testing.T) {
    content, err := os.ReadFile("../../tmp/Pipfile.lock")
    if err != nil {
        t.Skipf("Skipping test: tmp/Pipfile.lock not found: %v", err)
        return
    }

    analyzer := NewPipfileAnalyzer()
    deps, err := analyzer.parsePipfileLock(string(content))

    if err != nil {
        t.Fatalf("Failed to parse real Pipfile.lock: %v", err)
    }

    // Add specific validations...
}
```

### 3. Document expected content
Update this file with:
- What packages the file contains
- What makes the file interesting/challenging
- Any specific edge cases it tests

## Test File Structure

The `tmp/uv.lock` file structure:
```toml
version = 1
revision = 3
requires-python = ">=3.11"

[[package]]
name = "cfgv"
version = "3.4.0"
source = { registry = "https://pypidev.ivrtechnology.com/" }
sdist = { ... }
wheels = [ ... ]

[[package]]
name = "tmp"
version = "0.1.0"
source = { virtual = "." }
dependencies = [ ... ]

[package.dev-dependencies]
dev = [ ... ]
```

**Key features tested:**
- Registry source with custom URL
- Virtual package source
- Dev-dependencies section
- Multiple wheel files per package
- TOML array of tables syntax

## Best Practices

### DO:
✅ Use real files from actual projects
✅ Include comments explaining what makes the file interesting
✅ Handle missing files gracefully with `t.Skip()`
✅ Validate specific expected content
✅ Log detailed information with `t.Logf()`

### DON'T:
❌ Commit sensitive data (tokens, private repo info)
❌ Use files larger than a few hundred KB
❌ Fail tests when files are missing
❌ Make tests dependent on external resources

## Coverage Impact

Real file tests improve coverage by exercising:
- Complete parsing paths
- Real-world TOML/JSON structures
- Integration between components
- Error handling for complex inputs

Current coverage with real file tests:
```
pkg/dependencies    66.7% of statements
```

## Troubleshooting

### Test skipped: file not found
The test file is not present. This is normal if you haven't added it to your checkout. Clone with:
```bash
git lfs pull  # If using Git LFS
# or
cp /path/to/your/uv.lock tmp/
```

### Parse error on real file
If a real file fails to parse:
1. Check if it's a format version we don't support yet
2. Verify the file is valid (try parsing with uv itself)
3. Update the parser to handle the new format
4. Add a new synthetic test for the specific case

### Validation failures
If the test parses but validations fail:
1. Inspect the actual parsed content with `t.Logf()`
2. Verify the file hasn't changed
3. Update expected values if the file was intentionally updated
4. Check if the analyzer logic needs adjustment

## Related Documentation

- [Dependency Analysis](DEPENDENCIES.md) - Overview of dependency analyzers
- [Implementation Guide](DEPENDENCY_IMPLEMENTATION.md) - How to create analyzers
- [Logging](LOGGING.md) - Debug parsing issues

## Future Enhancements

Potential additions for more comprehensive real-file testing:

- [ ] poetry.lock from a real Poetry project
- [ ] Pipfile.lock from a real Pipenv project
- [ ] uv.lock files from different uv versions
- [ ] Files with all dependency types (git, path, url)
- [ ] Large files (1000+ dependencies)
- [ ] Files with complex markers and extras
